# Open Policy Agent

## What is Open Policy Agent?
Open Policy Agent (OPA) is a policy engine that can be used to implement fine-grained access control for your application. For example, you can use OPA to implement authorization across microservices. However, there is much more that can be accomplished with OPA. There are several open-source projects that integrate with OPA to implement fine-grained access control like [Docker](https://github.com/open-policy-agent/opa-docker-authz), [Istio](https://github.com/open-policy-agent/opa-istio-plugin) and [others](https://github.com/open-policy-agent/contrib). Furthermore, OPA as a general-purpose policy engine, can be leveraged in use cases beyond access control, for instance to make advanced pod placement decisions in [Kubernetes](https://github.com/open-policy-agent/opa-kube-scheduler).

OPA can be deployed as a standalone service along with your microservices. In order to protect your application, each request coming to a microservice must be authorized before it can be processed. To check the authorization, the microservice makes an API call to OPA to decide whether the request is authorized or not. Note that while you can offload authorization decisions from your application to OPA, your application still has to implement the enforcement of those decisions. For example, the application can ask OPA the question “Is user with with stationID 310 allowed to invoke GET /api/v1/persons/pid” and if OPA answers “No”, your application has to send HTTP 403 Forbidden back to the user.

OPA is written in the Go language and its source code is available on GitHub under the Apache License 2.0. 

## Making policy decisions

What does it take for OPA to make a policy decision? In OPA, there are three inputs into the decision-making process:

1. **Data** is a set of facts about the outside world that OPA refers to while making a decision. For example, when controlling access based on the access control list, the data would be a list of users along with the permissions they were granted. Another example: when deciding where to place the next pod on the Kubernetes cluster, the data would be a list of Kubernetes nodes and their currently available capacity. Note that data may change over time and OPA caches its latest state in memory. The data must be provided to OPA in the JSON format.
2. **Query** Input triggers the decision computation. It specifies the question that OPA should decide upon. The query input must be formatted as JSON. For instance, for the question “Is user Alice allowed to invoke GET /protected/resource?” the query input would contain parameters: Alice, GET, and /protected/resource.
3. **Policy** specifies the computational logic that for the given data and query input yields a policy decision aka query result. The computational logic is described as a set of policy rules in the OPA’s custom policy language called Rego. Note that OPA doesn’t come with any pre-defined policies. OPA is a policy engine that is able to interpret a policy, however, in order to make use of it you have to create a policy yourself and provide it to OPA.

In order to make a policy decision, all three inputs (data, query input, and the policy) are fed into the Policy Engine. The Policy Engine interprets the rules included in the policy and based on the data and the query input makes a policy decision. The policy decision generated by the Policy Engine is a JSON document.


## Spring AccessDecisionVoter using OPA


https://www.openpolicyagent.org/docs/latest/#running-opa

https://github.com/open-policy-agent/contrib/tree/master/spring_authz

docker run --rm openpolicyagent/opa:latest -p 8181:8181
git clone https://github.com/open-policy-agent/contrib.git
  
 
